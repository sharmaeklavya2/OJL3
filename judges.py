import os
import subprocess
import math
import shutil
import json
from collections import OrderedDict

OJL3_DIR = os.path.dirname(os.path.abspath(__file__))
SANDBOX_PATH = os.path.abspath(os.path.join(OJL3_DIR, "OJ_sandbox"))
SAFEEXEC_PATH = os.path.join(OJL3_DIR, "safeexec")

DEFAULT_TIME_LIM_S = 10
DEFAULT_MEM_LIM_K = 5000000
DEFAULT_OUTPUT_LIM_K = 1000000
SAFEEXEC_ARGS = ["--gid", "10000", "--nproc", "30"]

from OJL3 import langs

def run_prog(args, in_path=None, out_path=None, err_path=None, time_lim_s=None, mem_lim_k=None, output_lim_k=None, exec_path=None, report_path=None):
	"""
	Runs a program using safeexec

	Input parameters:
	args: Command line to be executed
	in_path: Path to file which is to be passed as STDIN of the program
	out_path: Path to file which will receive the STDOUT the program
	err_path: Path to file which will receive the STDERR the program
	exec_path: Path to the directory where the program required to be executed
	report_path: Path of the file which will store the report generated by safeexec
	time_lim_s: time limit in seconds
	mem_lim_k: memory limit in KiB

	Return value: a 5-tuple of the form (verdict, out, err, time_s, mem_k)
	verdict: verdict given by parse_report
	out: STDOUT of the program (if out_path is None)
	err: STDERR of the program (if err_path is None)
	time_s: CPU time of the program in seconds
	mem_k: Memory used by the program in KiB
	"""

	if report_path:
		report_args = ["--report_file", report_path]
	else:
		report_args = []

	if mem_lim_k==None:
		mem_lim_k = DEFAULT_MEM_LIM_K
	if time_lim_s==None:
		time_lim_s = DEFAULT_TIME_LIM_S
	if output_lim_k==None:
		output_lim_k = DEFAULT_OUTPUT_LIM_K

	run_path = [SAFEEXEC_PATH] + SAFEEXEC_ARGS + ["--clock", str(math.ceil(time_lim_s)), "--mem", str(mem_lim_k), "--fsize", str(output_lim_k)] + report_args + ["--exec"] + args

	if in_path: in_file_obj = open(in_path)
	else: in_file_obj = None
	if out_path: out_file_obj = open(out_path, "w")
	else: out_file_obj = subprocess.PIPE
	if err_path: err_file_obj = open(err_path, "w")
	else: err_file_obj = subprocess.PIPE

	sp = subprocess.Popen(run_path, stdin=in_file_obj, cwd=exec_path, stdout=out_file_obj, stderr=err_file_obj, universal_newlines=True)
	try:
		(out, err) = sp.communicate()
	except UnicodeDecodeError:
		sp.kill()
		return ("UNIE", None, "UnicodeDecodeError caught", 0, 0)
	verdict, time_s, mem_k = parse_report(open(report_path).read().strip().split('\n'), time_lim_s=time_lim_s)
	return (verdict, out, err, time_s, mem_k)

def parse_report(report_lines, time_lim_s):
	"""
	Reads report generated by safeexec.

	Pass the lines read from the file as arguments:
	open(report_path).read().strip().split('\n')

	Returns a triplet (verdict, time_s, mem_k):
	verdict: OK, TLE, NZEC or name of signal which terminated the program
	time_s: CPU time of program in seconds
	mem_k: memory used by the program in KiB
	"""
	mem_k = int(report_lines[2].split()[2])
	time_s = float(report_lines[3].split()[2])
	if report_lines[0] == "OK":
		verdict = "OK"
		if time_s>time_lim_s:
			verdict = "TLE"
	elif report_lines[0] == "Time Limit Exceeded":
		verdict = "TLE"
	elif report_lines[0].startswith("Command exited with non-zero status"):
		verdict = "NZEC"
	elif report_lines[0].startswith("Command terminated by signal"):
		verdict = report_lines[0].rsplit(maxsplit=1)[1][:-1]
	else:
		raise Exception("Unknown verdict "+report_lines[0])
	return (verdict, time_s, mem_k)

import filecmp
def have_same_content(path1, path2):
	filecmp.clear_cache()
	return filecmp.cmp(path1, path2)

#def have_same_content(path1, path2):
#	return open(path1, "rb").read() == open(path2, "rb").read()

def make_prison(prison_cell_path, lang, source_path, overwrite_prison_cell=False):
	"""
	Makes a prison cell where submitted programs can run. It compiles user's code (or copies it if it is not meant to be compiled) into prison_cell_path and returns the path to compiled (or copied) program.
	prison_cell_path: Path to directory in which program will run
	lang: Language in which source code is written
	source_path: path to the source code which has to be run
	"""
	# set up prison cell and put compiled source in it
	if os.path.exists(prison_cell_path) and overwrite_prison_cell:
		shutil.rmtree(prison_cell_path)
	os.makedirs(prison_cell_path, mode=0o771)
#	os.makedirs(user_out_dir, mode=0o771)
#	os.makedirs(user_err_dir, mode=0o771)
	dest_path = langs.compile_source(lang=lang, source_path=source_path, dest_dir_path=prison_cell_path)
	return dest_path

def run_IOCJ(prob_path, prison_cell_path, lang, prog_path, time_lim_s=None, mem_lim_k=None, output_lim_k=None):
	"""
	This is a SPOJ-style OJ (IOCJ: Input-Output Comparing Judge)
	Runs all test cases against the given code and gives a verdict for each test case
	prob_path: Path to problem directory
	prison_cell_path: Path to directory in which program will run
	lang: Language in which compiled code is written
	prog_path: path to the program which has to be run
	"""
	report_path = os.path.join(prison_cell_path, "report.txt")
	user_out_dir = os.path.join(prison_cell_path, "out")
	user_err_dir = os.path.join(prison_cell_path, "err")

	# TODO: run program on in.txt if it exists

	# run program on all input folders
	result = {}
	in_dir = os.path.join(prob_path, "in")
	out_dir = os.path.join(prob_path, "out")
	args = langs.get_prog_exec_args(lang, prog_path)
	result = OrderedDict()
	for (curr_in_dir, dir_names, file_names) in os.walk(in_dir):
		dir_names = sorted(dir_names)
		file_names = sorted(file_names)
		if curr_in_dir==in_dir:
			rel_path = ''
		else:
			rel_path = os.path.relpath(curr_in_dir, in_dir)
		curr_out_dir = os.path.join(out_dir, rel_path)
		curr_user_out_dir = os.path.join(user_out_dir, rel_path)
		curr_user_err_dir = os.path.join(user_err_dir, rel_path)
		os.makedirs(curr_user_out_dir)
		os.makedirs(curr_user_err_dir)

		for fname in file_names:
			in_path = os.path.join(curr_in_dir, fname)
			rel_in_path = os.path.join(rel_path, fname)
			out_path = os.path.join(curr_out_dir, fname)
			user_out_path = os.path.join(curr_user_out_dir, fname)
			user_err_path = os.path.join(curr_user_err_dir, fname)
			(verdict, out, err, time_s, mem_k) = run_prog(args, in_path=in_path, out_path=user_out_path, err_path=user_err_path, exec_path=prison_cell_path, report_path=report_path, time_lim_s=time_lim_s, mem_lim_k=mem_lim_k, output_lim_k=output_lim_k)
			if verdict=="OK":
				if have_same_content(out_path, user_out_path):
					verdict = "AC"
				else:
					verdict = "WA"
			result[rel_in_path] = OrderedDict([("verdict", verdict), ("time_s", time_s), ("mem_k", mem_k)])
#	shutil.rmtree(prison_cell_path)
	return result

def get_final_verdict(result):
	got_ac = True
	for test_case_result in result.values():
		if test_case_result["verdict"]!="AC":
			got_ac = False
	if got_ac:
		return "PASS"
	else:
		return "FAIL"

def send_to_IOCJ(prob_path, submission_code, lang, source_path, time_lim_s=None, mem_lim_k=None, output_lim_k=None, overwrite_prison_cell=False):
	"""
	This is a SPOJ-style OJ
	prob_path: Path to problem directory
	submission_code: string
	lang: Language in which compiled code is written
	source_path: path to the source code which has to be run
	"""
	prison_cell_path = os.path.join(SANDBOX_PATH, submission_code)
	(success, out, prog_path) = make_prison(prison_cell_path=prison_cell_path, lang=lang, source_path=source_path, overwrite_prison_cell=overwrite_prison_cell)
	if not success:
		return ("CMPLE", out)
	lang2 = langs.get_compiled_lang(lang)
	try:
		prob_data_path = os.path.join(prob_path, "data.json")
		prob_data = json.load(open(prob_data_path))
		if time_lim_s==None:
			time_lim_s = prob_data.get("time_lim_s", None)
		if mem_lim_k==None:
			mem_lim_k = prob_data.get("mem_lim_k", None)
		if output_lim_k==None:
			output_lim_k = prob_data.get("output_lim_k", None)
	except FileNotFoundError:
		pass
	except ValueError as e:
		print("Invalid JSON in", prob_data_path)
		print(e)
	result = run_IOCJ(prob_path=prob_path, prison_cell_path=prison_cell_path, lang=lang2, prog_path=prog_path, time_lim_s=time_lim_s, mem_lim_k=mem_lim_k, output_lim_k=output_lim_k)
	final_verdict = get_final_verdict(result)
#	shutil.rmtree(prison_cell_path)
	return (final_verdict, result)
